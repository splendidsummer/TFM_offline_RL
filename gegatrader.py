'''
EXAMPLE AUTO TRADER

Do not edit this file directly. Instead, copy it somewhere else in your workspace.
These are simple bots that illustrate the Optibook API and some simple trading concepts. These bots will not make a profit.

This is an example bot that trades a single instrument C2_GREEN_ENERGY_ETF.
All it does is to randomly insert either a BID or an ASK every 5 seconds.
The price at which it inserts is equal to the opposite side of the order book.
Thus, if the best bid in the order book is currently 90, it will send a sell order for price 90.
If the best ask in the order book is 91, it will send a buy order for price 91.

The order type this bot uses is IOC (immediate or cancel). This means that if the order does not
immediately trade, it will not be visible to others in the order book. Instead, it will be cancelled automatically.
'''
import logging
import time
from typing import List
from optibook import common_types as t
from optibook import ORDER_TYPE_IOC, ORDER_TYPE_LIMIT, SIDE_ASK, SIDE_BID
from optibook.exchange_responses import InsertOrderResponse
from optibook.synchronous_client import Exchange
import random
import json
import pandas as pd
from collections import namedtuple

TradeSet = namedtuple('TradeSet', ['basket', 's1', 's2'])

logging.getLogger('client').setLevel('ERROR')
logger = logging.getLogger(__name__)

trade_sets = [
    TradeSet('C2_GREEN_ENERGY_ETF', 'C2_SOLAR_CO', 'C2_WIND_LTD'),
    TradeSet('C1_FOSSIL_FUEL_ETF', 'C1_GAS_INC', 'C1_OIL_CORP'),
]

LOG_STEPS = 300
SLEEP_DURATION_SEC = 1 / 15

MAX_TRADE_VOLUME = 124
MAX_HEDGE = 250


def print_report(e: Exchange):
    '''
    Print my trades, my PNL and my current positions.
    '''
    pnl = e.get_pnl()
    positions = e.get_positions()

    logger.info("")
    for ts in trade_sets:
        my_trades = e.poll_new_trades(ts.basket)
        all_market_trades = e.poll_new_trade_ticks(ts.basket)
        logger.info(
            f'Our {ts.basket: <19} trades: {len(my_trades): 2d} / {len(all_market_trades): 2d}   since the last report.')

    logger.info(f'PNL is: {pnl:.2f}')
    logger.info(f'positions:"')
    for k, v in positions.items():
        logger.info(f'  {k: <20}: {v: 5d}')
    logger.info("")


def print_order_response(order_response: InsertOrderResponse):
    '''
    Print ok or error
    '''
    if order_response.success:
        logger.info(f"Inserted order successfully, order_id='{order_response.order_id}'")
    else:
        logger.info(f"Unable to insert order with reason: '{order_response.success}'")


def sell_strategy(e: Exchange, basket_book, stock1_book, stock2_book, max_volume, bad_ballance=False):
    if not (basket_book.bids and stock1_book.asks and stock2_book.asks):
        return False  # some trades are not available

    to_get = basket_book.bids[0].price * 2
    to_spend = stock1_book.asks[0].price + stock2_book.asks[0].price

    if to_spend > to_get:
        return False  # no exploit

    if to_spend == to_get and bad_ballance:
        return False  # no revenue and would lead to more inbalance

    stock_vol = min(basket_book.bids[0].volume // 2, stock1_book.asks[0].volume, stock2_book.asks[0].volume, max_volume)
    if stock_vol < 1:
        return False  # not enough volume to be traded

    revenue = to_get - to_spend
    logger.info(
        f'Basket is undervalued, buying basket and selling individual stocks. Expected revenue: {revenue * stock_vol:.2f} ({stock_vol})')

    response1: InsertOrderResponse = e.insert_order(basket_book.instrument_id, price=basket_book.bids[0].price,
                                                    volume=stock_vol * 2, side=SIDE_ASK, order_type=ORDER_TYPE_LIMIT)
    response2: InsertOrderResponse = e.insert_order(stock1_book.instrument_id, price=stock1_book.asks[0].price,
                                                    volume=stock_vol, side=SIDE_BID, order_type=ORDER_TYPE_LIMIT)
    response3: InsertOrderResponse = e.insert_order(stock2_book.instrument_id, price=stock2_book.asks[0].price,
                                                    volume=stock_vol, side=SIDE_BID, order_type=ORDER_TYPE_LIMIT)

    return True


def buy_strategy(e: Exchange, basket_book, stock1_book, stock2_book, max_volume, bad_ballance=False):
    if not (basket_book.asks and stock1_book.bids and stock2_book.bids):
        return False  # some trades are not available

    to_get = stock1_book.bids[0].price + stock2_book.bids[0].price
    to_spend = basket_book.asks[0].price * 2

    if to_spend > to_get:
        return False  # no exploit

    if to_spend == to_get and bad_ballance:
        return False  # no revenue and would lead to more inbalance

    stock_vol = min(basket_book.asks[0].volume // 2, stock1_book.bids[0].volume, stock2_book.bids[0].volume, max_volume)
    if stock_vol < 1:
        return False  # not enough volume to be traded

    revenue = to_get - to_spend
    logger.info(
        f'Basket is overvalues, selling basket and buying individual stocks. Expected revenue: {revenue * stock_vol:.2f} ({stock_vol})')

    response1: InsertOrderResponse = e.insert_order(basket_book.instrument_id, price=basket_book.asks[0].price,
                                                    volume=stock_vol * 2, side=SIDE_BID, order_type=ORDER_TYPE_LIMIT)
    response2: InsertOrderResponse = e.insert_order(stock1_book.instrument_id, price=stock1_book.bids[0].price,
                                                    volume=stock_vol, side=SIDE_ASK, order_type=ORDER_TYPE_LIMIT)
    response3: InsertOrderResponse = e.insert_order(stock2_book.instrument_id, price=stock2_book.bids[0].price,
                                                    volume=stock_vol, side=SIDE_ASK, order_type=ORDER_TYPE_LIMIT)

    return True


def trade_cycle(e: Exchange, max_volume=20, max_unbalance=20):
    '''
    Main bot logic
    '''

    positions = e.get_positions()

    for ts in trade_sets:
        basket_book = e.get_last_price_book(ts.basket)
        s1_book = e.get_last_price_book(ts.s1)
        s2_book = e.get_last_price_book(ts.s2)

        if positions[ts.basket] < max_unbalance:
            buy_strategy(e, basket_book, s1_book, s2_book, max_volume, positions[ts.basket] < 0)

        if positions[ts.basket] > -max_unbalance:
            sell_strategy(e, basket_book, s1_book, s2_book, max_volume, positions[ts.basket] > 0)


def main():
    exchange = Exchange()
    exchange.connect()

    # you can also define host/user/pass yourself
    # when not defined, it is taken from ~/.optibook file if it exists
    # if that file does not exists, an error is thrown
    # exchange = Exchange(host='host-to-connect-to', info_port=7001, exec_port=8001, username='your-username', password='your-password')
    # exchange.connect()

    step_counter = 0
    while True:
        try:
            trade_cycle(exchange, MAX_TRADE_VOLUME, MAX_HEDGE)
        except Exception as e:
            estr = str(e)
            print(estr)
            if "Order canceled because it would lead to a self-trade" in estr:
                logger.warn("!!! SELF TRADE !!!")
                exchange = Exchange()
                exchange.connect()
            else:
                raise

        if step_counter % LOG_STEPS == 0:
            print_report(exchange)

        step_counter += 1
        time.sleep(SLEEP_DURATION_SEC)


if __name__ == '__main__':
    main()
