'''
EXAMPLE AUTO TRADER

Do not edit this file directly. Instead, copy it somewhere else in your workspace.
These are simple bots that illustrate the Optibook API and some simple trading concepts. These bots will not make a profit.

This is an example bot that trades a single instrument C2_GREEN_ENERGY_ETF.
All it does is to randomly insert either a BID or an ASK every 5 seconds.
The price at which it inserts is equal to the opposite side of the order book.
Thus, if the best bid in the order book is currently 90, it will send a sell order for price 90.
If the best ask in the order book is 91, it will send a buy order for price 91.

The order type this bot uses is IOC (immediate or cancel). This means that if the order does not
immediately trade, it will not be visible to others in the order book. Instead, it will be cancelled automatically.
'''
import logging
import time
from typing import List
from optibook import common_types as t
from optibook import ORDER_TYPE_IOC, ORDER_TYPE_LIMIT, SIDE_ASK, SIDE_BID
from optibook.exchange_responses import InsertOrderResponse
from optibook.synchronous_client import Exchange
import random
import json
import pandas as pd

from collections import namedtuple

TradeSet = namedtuple('TradeSet', ['basket', 's1', 's2'])
LimitOrderMemory = namedtuple('LimitOrderMemory', ['id', 'price', 'volume', 'stock1', 'stock2', 'expected_profit'])

average_asks = {}
average_bids = {}

logging.getLogger('client').setLevel('ERROR')
logger = logging.getLogger(__name__)

trade_sets = [
    TradeSet('C2_GREEN_ENERGY_ETF', 'C2_SOLAR_CO', 'C2_WIND_LTD'),
    TradeSet('C1_FOSSIL_FUEL_ETF', 'C1_GAS_INC', 'C1_OIL_CORP'),
]

all_instruments = []
for ts in trade_sets:
    all_instruments.extend(ts)

order_mem = {};

LOG_STEPS = 300
SLEEP_DURATION_SEC = 1 / 8
SLEEP_TRANSACTION = 0.04

MAX_TPS = 24

MAX_TRADE_VOLUME = 200
MAX_HEDGE = 230
max_volume_gap = 40


def print_report(e: Exchange):
    '''
    Print my trades, my PNL and my current positions.
    '''
    pnl = e.get_pnl()
    positions = e.get_positions()

    logger.info("")
    for ts in trade_sets:
        my_trades = e.poll_new_trades(ts.basket)
        all_market_trades = e.poll_new_trade_ticks(ts.basket)
        logger.info(
            f'Our {ts.basket: <19} trades: {len(my_trades): 2d} / {len(all_market_trades): 2d}   since the last report.')

    logger.info(f'PNL is: {pnl:.2f}')
    logger.info(f'positions:"')
    for k, v in positions.items():
        logger.info(f'  {k: <20}: {v: 5d}')
    logger.info("")


def print_order_response(order_response: InsertOrderResponse):
    '''
    Print ok or error
    '''
    if order_response.success:
        logger.info(f"Inserted order successfully, order_id='{order_response.order_id}'")
    else:
        logger.info(f"Unable to insert order with reason: '{order_response.success}'")


def print_book(e: Exchange, basket_id: str, instrument_id: str, step=0.1):
    book = e.get_last_price_book(basket_id)

    # min_price = [x.value book.asks


def read_books(e: Exchange, ts):
    return e.get_last_price_book(ts.basket), e.get_last_price_book(ts.s1), e.get_last_price_book(ts.s2)


def order_status(basket_id, orders):
    """ """
    global order_mem

    diffp = 0
    diffn = 0
    value = 0
    expected_profit = 0
    # buying
    cur_mem = order_mem.get((basket_id, "bid"))
    if cur_mem:
        if cur_mem.id not in orders:
            diffp = cur_mem.volume
        else:
            diffp = cur_mem.volume - orders[cur_mem.id].volume

        value += diffp * cur_mem.price
        expected_profit += diffp * cur_mem.expected_profit

    # selling
    cur_mem = order_mem.get((basket_id, "ask"))
    if cur_mem:
        if cur_mem.id not in orders:
            diffn = cur_mem.volume
        else:
            diffn = (cur_mem.volume - orders[cur_mem.id].volume)
        value += diffn * cur_mem.price
        expected_profit += diffn * cur_mem.expected_profit

    return diffp - diffn, value, expected_profit


def sell_stock_best_price(e, stock_id, volume):
    stock_book = e.get_last_price_book(stock_id)

    i = 0
    price = 0
    rvolume = volume
    while rvolume > 0 and i < len(stock_book.asks):
        price = stock_book.asks[i].price
        rvolume -= stock_book.asks[i].volume
        i += 1

    if rvolume > 0:
        logger.info(f'Sold only {volume - rvolume} / {volume} of {stock_id}')
        volume -= rvolume

    if volume > 0:
        e.insert_order(stock_id, price=price, volume=volume, side=SIDE_ASK, order_type=ORDER_TYPE_IOC)

    return price * volume


def buy_stock_best_price(e, stock_id, volume):
    stock_book = e.get_last_price_book(stock_id)

    i = 0
    price = 0
    rvolume = volume
    while rvolume > 0 and i < len(stock_book.bids):
        price = stock_book.bids[i].price
        rvolume -= stock_book.bids[i].volume
        i += 1

    if rvolume > 0:
        logger.info(f'Bought only {volume - rvolume} / {volume} of {stock_id}')
        volume -= rvolume

    if volume > 0:
        e.insert_order(stock_id, price=price, volume=volume, side=SIDE_BID, order_type=ORDER_TYPE_IOC)

    return price * volume


def clear_memory(basket_id):
    global order_mem

    if (basket_id, "ask") in order_mem: del order_mem[basket_id, "ask"]
    if (basket_id, "bid") in order_mem: del order_mem[basket_id, "bid"]


def reduce_gap_pre(e, ts):
    global order_mem

    orders = e.get_outstanding_orders(ts.basket)
    baskets_delta, value, expected_profit = order_status(ts.basket, orders)
    e.delete_orders(ts.basket)
    clear_memory(ts.basket)

    costs = 0
    if baskets_delta >= 2:
        # sell stock
        costs += sell_stock_best_price(e, ts.s1, baskets_delta // 2)
        costs += sell_stock_best_price(e, ts.s2, baskets_delta // 2)

    if baskets_delta <= -2:
        # buy stock
        costs += buy_stock_best_price(e, ts.s1, -baskets_delta // 2)
        costs += buy_stock_best_price(e, ts.s2, -baskets_delta // 2)

    if expected_profit != 0:
        logger.info(f'MarketMaking: profit:{value - costs:.2f}, expected: {expected_profit:.2f}')


def reduce_gap_sell(e: Exchange, ts, volume):
    global order_mem

    basket_book, stock1_book, stock2_book = read_books(e, ts)

    # make new order
    if not (stock1_book.asks and stock2_book.asks):
        return
    stock_buy_price = (stock1_book.asks[0].price + stock2_book.asks[0].price) / 2
    if basket_book.asks:
        basket_sell_price = basket_book.asks[0].price
    else:
        basket_sell_price = 1.05 * stock_buy_price
    if basket_sell_price < stock_buy_price:
        return  # we would not profit, should be exploitable
    price = stock_buy_price * 0.8 + basket_sell_price * 0.2
    basket_order: InsertOrderResponse = e.insert_order(basket_book.instrument_id, price=price, volume=volume,
                                                       side=SIDE_ASK, order_type=ORDER_TYPE_LIMIT)

    if (basket_book.instrument_id, "ask") in order_mem:
        logger.warn("!!! Overwriting order memory !!!")
    expected_profit = price - stock_buy_price
    order_mem[basket_book.instrument_id, "ask"] = LimitOrderMemory(
        basket_order.order_id, price, volume, stock1_book.asks[0].price, stock2_book.asks[0].price, expected_profit)
    # logger.info(f'setting order of {volume} {basket_book.instrument_id} with price {price:.1f}')
    time.sleep(SLEEP_TRANSACTION)


def reduce_gap_buy(e: Exchange, ts, volume):
    global order_mem

    basket_book, stock1_book, stock2_book = read_books(e, ts)

    # make new order
    if not (stock1_book.bids and stock2_book.bids):
        # logger.info(f'No s1 or s2 bids')
        return
    stock_sell_price = (stock1_book.bids[0].price + stock2_book.bids[0].price) / 2
    if basket_book.bids:
        basket_buy_price = basket_book.bids[0].price
    else:
        basket_buy_price = 1.05 * stock_sell_price
    if basket_buy_price < stock_sell_price:
        return  # we would not profit, should be exploitable
    price = stock_sell_price * 0.8 + basket_buy_price * 0.2
    basket_order: InsertOrderResponse = e.insert_order(basket_book.instrument_id, price=price, volume=volume,
                                                       side=SIDE_BID, order_type=ORDER_TYPE_LIMIT)

    if (basket_book.instrument_id, "bid") in order_mem:
        logger.warn("!!! Overwriting order memory !!!")
    expected_profit = price - stock_sell_price
    order_mem[basket_book.instrument_id, "bid"] = LimitOrderMemory(
        basket_order.order_id, price, volume, stock1_book.bids[0].price, stock2_book.bids[0].price, expected_profit)
    # logger.info(f'setting order of {volume} {basket_book.instrument_id} with price {price:.1f}')
    time.sleep(SLEEP_TRANSACTION)


def sell_strategy(e: Exchange, ts, max_volume, bad_ballance=False):
    basket_book, stock1_book, stock2_book = read_books(e, ts)

    if not (basket_book.bids and stock1_book.asks and stock2_book.asks):
        return False  # some trades are not available

    to_get = basket_book.bids[0].price * 2
    to_spend = stock1_book.asks[0].price + stock2_book.asks[0].price

    if to_spend > to_get:
        return False  # no exploit

    if to_spend == to_get and bad_ballance:
        return False  # no revenue and would lead to more inbalance

    stock_vol = min(basket_book.bids[0].volume // 2, stock1_book.asks[0].volume, stock2_book.asks[0].volume,
                    max_volume // 2)
    if stock_vol < 1:
        return False  # not enough volume to be traded

    revenue = to_get - to_spend
    logger.info(f'Exploiting - buy basket. Expected revenue: {revenue * stock_vol:.2f} ({stock_vol})')

    response1: InsertOrderResponse = e.insert_order(basket_book.instrument_id, price=basket_book.bids[0].price,
                                                    volume=stock_vol * 2, side=SIDE_ASK, order_type=ORDER_TYPE_IOC)
    response2: InsertOrderResponse = e.insert_order(stock1_book.instrument_id, price=stock1_book.asks[0].price,
                                                    volume=stock_vol, side=SIDE_BID, order_type=ORDER_TYPE_IOC)
    response3: InsertOrderResponse = e.insert_order(stock2_book.instrument_id, price=stock2_book.asks[0].price,
                                                    volume=stock_vol, side=SIDE_BID, order_type=ORDER_TYPE_IOC)

    time.sleep(3 * SLEEP_TRANSACTION)

    return True


def buy_strategy(e: Exchange, ts, max_volume, bad_ballance=False):
    basket_book, stock1_book, stock2_book = read_books(e, ts)

    if not (basket_book.asks and stock1_book.bids and stock2_book.bids):
        return False  # some trades are not available

    to_get = stock1_book.bids[0].price + stock2_book.bids[0].price
    to_spend = basket_book.asks[0].price * 2

    if to_spend > to_get:
        return False  # no exploit

    if to_spend == to_get and bad_ballance:
        return False  # no revenue and would lead to more inbalance

    stock_vol = min(basket_book.asks[0].volume // 2, stock1_book.bids[0].volume, stock2_book.bids[0].volume,
                    max_volume // 2)
    if stock_vol < 1:
        return False  # not enough volume to be traded

    revenue = to_get - to_spend
    logger.info(f'Exploiting - sell basket. Expected revenue: {revenue * stock_vol:.2f} ({stock_vol})')

    response1: InsertOrderResponse = e.insert_order(basket_book.instrument_id, price=basket_book.asks[0].price,
                                                    volume=stock_vol * 2, side=SIDE_BID, order_type=ORDER_TYPE_IOC)
    response2: InsertOrderResponse = e.insert_order(stock1_book.instrument_id, price=stock1_book.bids[0].price,
                                                    volume=stock_vol, side=SIDE_ASK, order_type=ORDER_TYPE_IOC)
    response3: InsertOrderResponse = e.insert_order(stock2_book.instrument_id, price=stock2_book.bids[0].price,
                                                    volume=stock_vol, side=SIDE_ASK, order_type=ORDER_TYPE_IOC)

    time.sleep(3 * SLEEP_TRANSACTION)

    return True


def update_average(instrument_id, value, ask=True):
    """
    Update exponential average of asks or bids of given instrumet by a value
    """
    global average_bids
    global average_asks
    if ask:
        if instrument_id not in average_asks:
            average_asks[instrument_id] = value
        else:
            average_asks[instrument_id] = average_asks[instrument_id] * 0.95 + value * 0.05
    else:
        if instrument_id not in average_bids:
            average_bids[instrument_id] = value
        else:
            average_bids[instrument_id] = average_bids[instrument_id] * 0.95 + value * 0.05


def update_averages(basket_book, s1_book, s2_book, ts):
    """
    update all averages associated with given trade set according to current books
    """
    if basket_book.asks:
        update_average(ts.basket, basket_book.asks[0].price, True)
    if s1_book.asks:
        update_average(ts.s1, s1_book.asks[0].price, True)
    if s2_book.asks:
        update_average(ts.s2, s2_book.asks[0].price, True)
    if basket_book.bids:
        update_average(ts.basket, basket_book.bids[0].price, False)
    if s1_book.bids:
        update_average(ts.s1, s1_book.bids[0].price, False)
    if s2_book.bids:
        update_average(ts.s2, s2_book.bids[0].price, False)


def rehedging(e: Exchange, ts):
    """
    Try to buy or sell instruments in a trade set to that their positions will be hedged.
    Trades only if the current price is better than average.
    """
    basket_book = e.get_last_price_book(ts.basket)
    s1_book = e.get_last_price_book(ts.s1)
    s2_book = e.get_last_price_book(ts.s2)
    positions = e.get_positions()

    update_averages(basket_book, s1_book, s2_book, ts)

    orders_made = 0

    if positions[ts.s1] < positions[ts.s2]:
        if s2_book.bids and s2_book.bids[0].price > average_bids[ts.s2]:
            volume = min(positions[ts.s2] - positions[ts.s1], s2_book.bids[0].volume)
            e.insert_order(ts.s2, price=s2_book.bids[0].price,
                           volume=volume, side=SIDE_ASK, order_type=ORDER_TYPE_IOC)
            logger.info(f'Rehedging: sell {volume} of {ts.s2}')
            # print_report(e)
            orders_made += 1
    if positions[ts.s1] > positions[ts.s2]:
        if s2_book.asks and s2_book.asks[0].price < average_asks[ts.s2]:
            volume = min(positions[ts.s1] - positions[ts.s2], s2_book.asks[0].volume)
            e.insert_order(ts.s2, price=s2_book.asks[0].price,
                           volume=volume, side=SIDE_BID, order_type=ORDER_TYPE_IOC)
            logger.info(f'Rehedging: buy {volume} of {ts.s2}')
            # print_report(e)
            orders_made += 1
    if -2 * positions[ts.s1] < positions[ts.basket]:
        if basket_book.bids and basket_book.bids[0].price > average_bids[ts.basket]:
            volume = min(positions[ts.basket] - (-2) * positions[ts.s1], basket_book.bids[0].volume)
            e.insert_order(ts.basket, price=basket_book.bids[0].price,
                           volume=volume, side=SIDE_ASK, order_type=ORDER_TYPE_IOC)
            logger.info(f'Rehedging: sell {volume} of {ts.basket}')
            # print_report(e)
            orders_made += 1
    if -2 * positions[ts.s1] > positions[ts.basket]:
        if basket_book.asks and basket_book.asks[0].price < average_asks[ts.basket]:
            volume = min(-2 * positions[ts.s1] - positions[ts.basket], basket_book.asks[0].volume)
            e.insert_order(ts.basket, price=basket_book.asks[0].price,
                           volume=volume, side=SIDE_BID, order_type=ORDER_TYPE_IOC)
            logger.info(f'Rehedging: buy {volume} of {ts.basket}')
            # print_report(e)
            orders_made += 1

    time.sleep(orders_made * SLEEP_TRANSACTION)


def trade_cycle(e: Exchange, max_volume=20, max_unbalance=20):
    '''
    Main bot logic
    '''

    positions = e.get_positions()

    for ts in trade_sets:
        if positions[ts.basket] < max_unbalance:
            reduce_gap_pre(e, ts)
            rehedging(e, ts)
            buy_strategy(e, ts, max_volume, positions[ts.basket] < 0)
            if time.time() % 10 < 2:
                reduce_gap_buy(e, ts, max_volume_gap)

        if positions[ts.basket] > -max_unbalance:
            reduce_gap_pre(e, ts)
            rehedging(e, ts)
            sell_strategy(e, ts, max_volume, positions[ts.basket] > 0)
            if time.time() % 10 < 2:
                reduce_gap_sell(e, ts, max_volume_gap)


def dump_orders(e):
    for iid in all_instruments:
        orders = e.get_outstanding_orders(iid)
        if not orders:
            continue
        print(iid)
        for v in orders.values():
            print("   ", v)


def clear_orders(e):
    for iid in all_instruments:
        orders = e.get_outstanding_orders(iid)
        if not orders:
            continue
        print(iid)
        for k in orders.keys():
            e.delete_order(iid, order_id=k)


def main():
    exchange = Exchange()
    exchange.connect()

    # you can also define host/user/pass yourself
    # when not defined, it is taken from ~/.optibook file if it exists
    # if that file does not exists, an error is thrown
    # exchange = Exchange(host='host-to-connect-to', info_port=7001, exec_port=8001, username='your-username', password='your-password')
    # exchange.connect()

    step_counter = 0

    clear_orders(exchange)

    while True:
        try:
            trade_cycle(exchange, MAX_TRADE_VOLUME, MAX_HEDGE)
        except Exception as e:
            estr = str(e)
            print(estr)
            if "Order canceled because it would lead to a self-trade" in estr:
                logger.warn("!!! SELF TRADE !!!")
                exchange = Exchange()
                exchange.connect()

                raise
            else:
                raise

        if step_counter % LOG_STEPS == 0:
            print_report(exchange)

        step_counter += 1
        # time.sleep(SLEEP_DURATION_SEC)


if __name__ == '__main__':
    main()
